<!DOCTYPE html>

<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>ParaSol.js Showcase</title>

  <!-- Core -->
  <link rel="stylesheet" type="text/css" href="styles/style_custom.css">
  <link rel="stylesheet" type="text/css" href="styles/d3.parcoords_ucb.css">

  <script type="text/javascript" src="src/d3.min.js"></script>
  <script type="text/javascript" src="src/d3-dsv.min.js"></script>
  <script type="text/javascript" src="src/d3.parcoords_ucb.js"></script>
  <script type="text/javascript" src="src/d3.svg.multibrush.js"></script>
  <script type="text/javascript" src="src/jquery-1.7.min.js"></script>
  <script type="text/javascript" src="src/underscore.js"></script>
  <script type="text/javascript" src="src/divgrid.js"></script>
  <script type="text/javascript" src="src/ml.min.js"></script>
  <script type="text/javascript" src="src/colorbrewer.js"></script>

  <!-- SlickGrid -->
  <link rel="stylesheet" href="src/slickgrid/slick.grid_default.css" type="text/css" media="screen" charset="utf-8">
  <link rel="stylesheet" href="src/slickgrid/jquery-ui-1.8.16.custom.css" type="text/css" />
  <link rel="stylesheet" href="src/slickgrid/plugins/slick.columnpicker.css" type="text/css"/>

  <script type="text/javascript" src="src/slickgrid/jquery.event.drag-2.0.min.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.core.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.grid.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.dataview.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.formatters.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.editors.js"></script>

  <script src="src/slickgrid/plugins/slick.checkboxselectcolumn.js"></script>
  <script src="src/slickgrid/plugins/slick.autotooltips.js"></script>
  <script src="src/slickgrid/plugins/slick.cellrangedecorator.js"></script>
  <script src="src/slickgrid/plugins/slick.cellrangeselector.js"></script>
  <script src="src/slickgrid/plugins/slick.cellcopymanager.js"></script>
  <script src="src/slickgrid/plugins/slick.cellselectionmodel.js"></script>
  <script src="src/slickgrid/plugins/slick.rowselectionmodel.js"></script>
  <script src="src/slickgrid/plugins/slick.columnpicker.js"></script>

</head>

<body>
<!-- Page Header -->
<div id="nav">
  <h1>ParaSol.js</h1>
    Links to info and tutorials:
    <a href="https://waterprogramming.wordpress.com/">Example</a>
    <a href="https://waterprogramming.wordpress.com/">Example</a>
</div>

<div id="main">
  <!-- Interactive Buttons -->
  <div class="widgets">
    <input type="file" id="uploader">
    <button id="keep_selected">Keep</button>
    <button id="remove_selected">Remove</button>
    <button href='#'id='export_selected'>Export</button>


    <button id="brush_reset">Reset Brushes</button>
    <button id="clear_selected">Clear Selections</button>

    <button id="show_axis">Show Clusters</button>
    <button id="hide_axis">Hide Clusters</button>
    <button id="axes_limits">Set Axes Limits</button>
    <!-- <input type="select" id="cluster">Clustering</input> -->
    <!-- <button id="cluster">Clustering</button> -->
    <button id="explore">Explore Selection</button>
  </div>
  <div id="plots"></div>
  <div id="grid"></div>

  <!-- Begin Script -->
  <script type="text/javascript">

    var plot = `<h3>Objective Space</h3>
    <button id="svg01">Save Image</button>
    <div id="plot01" class="parcoords" style="height:200px; width=100%;"></div>

    <h3>Decision Space</h3>
    <button id="svg02">Save Image</button>
    <div id="plot02" class="parcoords" style="height:200px; width=100%;"></div>
    `
    $("div#plots").html(plot);

    // clustering library
    var kmeans = ML.Clust.kmeans;

    function visualize(data, n_objs, k = 3) {

      // check that n_objs < length data - 1
      if (n_objs >= d3.keys(data[0]).length - 1) {
        throw new Error("Number of objectives exceeds length of data.");
      }

      // max clusters = 6
      k = (k <= 6) ?  k : 3;

      // coerce data to array of arrays for clustering
      var clust_form = [];
      data.forEach(function(d,i) { clust_form[i] = _.values(d) });

      // preform default clustering
      var km = kmeans(clust_form, k);
      data.forEach(function(d,i) { d.cluster = km.clusters[i]; });

      // slickgrid needs each data element to have an id
      data.forEach(function(d,i) { d.id = d.id || i; });

      // choose default catagorical color scheme
      var color_scheme = d3.scale.ordinal()
        .range(colorbrewer.Dark2[k])
      // can we use d3 instead, or is the new version not compatible
      // var color_scheme = d3.scaleOrdinal(d3.schemeCategory10);

      var palette = function(d) {
        return color_scheme(d['cluster']);
      };

      var variables = d3.keys(data[0]).slice(0,-1); //remove id col
      var id_col = "id"
      var k_col = "cluster";

      // NOTE: hide clusters by default but allow user to display via button
      var objective_vars = _.union(variables.slice(0, n_objs), [k_col], [id_col]);
      // var decision_vars = _.union(variables.slice(n_objs), [id_col])
      var decision_vars = _.difference(variables.slice(n_objs), [k_col]);
      decision_vars = _.union(decision_vars, [id_col]);

      console.log(d3.keys(data[0]));
      console.log(objective_vars);
      console.log(decision_vars);

      // keep track of hidden vars
      pc1_hidden = [];
      pc2_hidden = [];

      // keep track of brushed data
      var brushed_pc1 = [];
      var brushed_pc2 = [];
      var isBrushed_pc1 = false;
      var isBrushed_pc2 = false;


      // ---------------------
      // define parallel coordinates variables
      // ---------------------

      // objective space
      var pc1 = d3.parcoords()("#plot01")
        .data(data)
        .hideAxis(decision_vars)
        .color(palette)
        .height(200)
        .alpha(0.4)
        .mode("queue")
        .render()
        .shadows()
        .reorderable()
        .brushMode("1D-axes")
        .on("brushend", function(brushed) {

          if (isBrushed_pc2) {
            // pc2 has brushes, keep only the intersection of arrays
            brushed_pc2 = _.intersection(brushed_pc2, brushed);
          } else {
            brushed_pc2 = brushed;
          }

          brushed_pc1 = brushed_pc2;
          isBrushed_pc1 = true;

          pc2.brushed(brushed_pc2);
          pc2.render();

          pc1.brushed(brushed_pc1);
          pc1.render();

          gridUpdate(brushed_pc2);
        });

      // decision space
      var pc2 = d3.parcoords()("#plot02")
        .data(data)
        .hideAxis(objective_vars)
        .color(palette)
        .height(200)
        .alpha(0.4)
        .mode("queue")
        .render()
        .shadows()
        .reorderable()
        .brushMode("1D-axes")
        .on("brushend", function(brushed) {

          if (isBrushed_pc1) {
            // pc1 has brushes, keep only the intersection of arrays
            brushed_pc1 = _.intersection(brushed_pc1, brushed);
          } else {
            brushed_pc1 = brushed;
          }

          brushed_pc2 = brushed_pc1;
          isBrushed_pc2 = true;

          pc2.brushed(brushed_pc1);
          pc2.render();

          pc1.brushed(brushed_pc2);
          pc1.render();

          gridUpdate(brushed_pc1);
        });


      // ---------------------
      // slickgrid setup
      // ---------------------

      var column_keys = d3.keys(data[0]).slice(0,-1); //remove id col
      var columns = column_keys.map(function(key,i) {
        return {
          id: key,
          name: key,
          field: key,
          sortable: true
        }
      });

      var options = {
        enableCellNavigation: true,
        enableColumnReorder: false,
        multiColumnSort: false,
        editable: true,
        asyncEditorLoading: false,
        autoEdit: false
      };

      var checkboxSelector = new Slick.CheckboxSelectColumn({
        cssClass: "slick-cell-checkboxsel"
      });
      columns.unshift(checkboxSelector.getColumnDefinition());

      var dataView = new Slick.Data.DataView();
      var grid = new Slick.Grid("#grid", dataView, columns, options);
      grid.setSelectionModel(new Slick.RowSelectionModel({selectActiveRow: false}));
      grid.registerPlugin(checkboxSelector);

      // wire up model events to drive the grid
      dataView.onRowCountChanged.subscribe(function (e, args) {
        grid.updateRowCount();
        grid.render();
      });

      dataView.onRowsChanged.subscribe(function (e, args) {
        grid.invalidateRows(args.rows);
        grid.render();
      });

      // keep checkboxes matched with row on filter/brush
      dataView.syncGridSelection(grid, preserveHidden=false); //vs true

      // column sorting
      var sortcol = column_keys[0];
      var sortdir = 1;

      function comparer(a, b) {
        var x = a[sortcol], y = b[sortcol];
        return (x == y ? 0 : (x > y ? 1 : -1));
      }

      // click header to sort grid column
      grid.onSort.subscribe(function (e, args) {
        sortdir = args.sortAsc ? 1 : -1;
        sortcol = args.sortCol.field;

        if ($.browser.msie && $.browser.version <= 8) {
          dataView.fastSort(sortcol, args.sortAsc);
        } else {
          dataView.sort(comparer, args.sortAsc);
        }
      });

      // highlight row in chart
      grid.onMouseEnter.subscribe(function(e, args) {
        var i = grid.getCellFromEvent(e).row;
        var d1 = pc1.brushed() || data;
        var d2 = pc2.brushed() || data;
        pc1.highlight([d1[i]]);
        pc2.highlight([d2[i]]);
      });
      grid.onMouseLeave.subscribe(function(e, args) {
        pc1.unhighlight();
        pc2.unhighlight();
      });

      // select row in chart
      grid.onSelectedRowsChanged.subscribe(function (e, args) {
        // reset and update selected rows
        var selected_row_ids = grid.getSelectedRows();
        var brush_union = _.union(pc1.brushed(), pc2.brushed());
        var d;
        if (brush_union.length) {
          d = brush_union;
        } else {
          d = data;
        }
        pc1.deselect();
        pc2.deselect();
        selected_row_ids.forEach(function(i) {
           pc1.select([d[i]]);
           pc2.select([d[i]]);
         });
      });

      // fill grid with data
      gridUpdate(data);

      function gridUpdate(data) {
        dataView.beginUpdate();
        dataView.setItems(data);
        // if selected data exists, keep in grid
        // only need to look at once plot since selections are linked
        if (pc1.selected().length) {
          pc1.selected().forEach(function(i) { dataView.insertItem(0,i); });
        }
        dataView.endUpdate();
      };


      // ---------------------
      // button functionality
      // ---------------------

      // clear selections
      d3.select('#clear_selected').on('click', function() {
        // deselect all elements in grid (fires event)
        grid.setSelectedRows([]);
      });

      // reset brushes
      d3.select('#brush_reset').on('click', function() {
        // reset global vars
        brushed_pc1 = [];
        brushed_pc2 = [];
        isBrushed_pc1 = false;
        isBrushed_pc2 = false;

        pc1.brushReset();
        pc2.brushReset();

        gridUpdate(data);
      });

      // hide axis
      d3.select('#hide_axis').on('click', function() {
        var found = false;
        var input = ["cluster"];

        // NOTE: if we want to edit both plots at once, do it this way. if we only want to edit one at a time, do it as below
        if ( ! _.difference(input, variables).length ) {
          found = true;
          // in objectives so add it to decisions which are hidden
          // pc1_hidden.push(input[0]); // keep list of hidden
          // pc2_hidden.push(input[0]); // keep list of hidden

          decision_vars = _.union(decision_vars, input);
          objective_vars = _.union(objective_vars, input);

          pc1.hideAxis(decision_vars);
          pc1.render().updateAxes(500); // animationTime (ms)

          pc2.hideAxis(objective_vars);
          pc2.render().updateAxes(500); // animationTime (ms)
        }
        // if ( ! _.difference(input, decision_vars).length ) {
        //   found = true;
        //   console.log(_.difference(input, decision_vars));
        //   // in decisions so add it to objectives which are hidden
        //   pc2_hidden.push(input[0]); // keep list of hidden
        //   objective_vars = _.union(objective_vars, input);
        //   console.log(objective_vars);
        //   console.log(pc2_hidden);
        //   pc2.hideAxis(objective_vars);
        //   pc2.render().updateAxes(500); // animationTime (ms)
        // }
        if (found == false) {
          // not in dataset
          throw new Error("Variable not found.");
        }
        found = false;
      });

      // show axis
      d3.select('#show_axis').on('click', function() {
        var found = false;
        var input = ["cluster"];

        // NOTE: we use a two separate if statments since it is possible that a variable like 'cluster' could be in both plots
        if ( ! _.difference(input, decision_vars).length ) {
          found = true;
          // in hidden objectives so remove from decisions which are hidden
          //pc1_hidden = _.difference(pc1_hidden, input); // remove from list
          decision_vars = _.difference(decision_vars, input);
          console.log(decision_vars);
          //console.log(pc1_hidden);
          pc1.hideAxis(decision_vars);
          pc1.render().updateAxes(500); // animationTime (ms)
        }
        else if ( ! _.difference(input, objective_vars).length ) {
          found = true;
          // in hidden decisions so remove from objectives which are hidden
          objective_vars = _.difference(objective_vars, input);
          console.log(objective_vars);
          pc2.hideAxis(objective_vars);
          pc2.render().updateAxes(500); // animationTime (ms)
        }
        if (found == false) {
          // not in dataset
          throw new Error("Variable not hidden.");
        }
        found = false;
      });

      // set axis limits
      d3.select('#axes_limits').on('click', function() {

        // functions of interest
        // getRange
        // applyAxisConfig, and sub functions
      });


      // keep selected
      d3.select('#keep_selected').on('click', function() {
        // delete all data not slected and do complete refresh
        // only need to look at one plot since selections are linked
        var keep = pc1.selected() || pc1.brushed();
        console.log(keep);
        if (keep.length >= k ) {
          // clear canvas layers
          $("div#plot01").html("");
          $("div#plot02").html("");
          $("div#plot").html(plot);
          // for complete reset, clusters will be recomputed
          visualize(data, n_objs = n_objs, k = k);
        } else {
          throw new Error("Not enough data selected to perform clustering.");
        }
      });

      // remove selected
      d3.select('#remove_selected').on('click', function() {
        console.log("before:", data.length);
        // delete all selected data and do complete refresh
        if (pc1.selected().length) {
          data = _.difference(data, pc1.selected());
          if (data.length >= k) {
            // clear canvas layers
            $("div#plot01").html("");
            $("div#plot02").html("");
            $("div#plot").html(plot);
            // for complete reset, clusters will be recomputed
            visualize(data, n_objs = n_objs, k = k);
          }
        } else {
          throw new Error("Not enough data remaining to perform clustering.");
        }
        console.log("after:", data.length);
      });

      // export selected
      d3.select('#export_selected').on('click', function() {
        // export selected data to new csv and download
        // TODO: decide on what to export
        var data_exp = pc1.selected();

        if (data_exp == null || !data_exp.length) {
            throw new Error("No data selected.");
            return;
        }

        //remove id column
        data_exp.forEach(function(d) { delete d.id; });

        // format data as csv
        var columns = d3.keys(data_exp[0]);
        var csv = d3.csvFormat(data_exp, columns);

        // create url for download
        var file = new Blob([csv], {type: 'text/csv'});
        var url = URL.createObjectURL(file);
        console.log(url);

        // create hidden DOM element
        var filename = 'pareto_solutions.csv'
        var link = document.createElement('a');
        console.log(link);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        document.body.appendChild(link); // Required for FF
        link.click();

      });

    };


    // CSV Uploader
    var uploader = document.getElementById("uploader");
    var reader = new FileReader();

    reader.onload = function(e) {
      var contents = e.target.result;
      var data = d3.csv.parse(contents);
      // NOTE: remove after testing
      data.forEach(function(car) {
        delete car.name;
        delete car.year;
      });

      // // visualize data with default to 3 clusters
      visualize(data, n_objs = 3, k = 3);

      // remove uploader button, since re-initializing doesn't work
      uploader.parentNode.removeChild(uploader);
    };

    uploader.addEventListener("change", handleFiles, false);

    function handleFiles() {
      var file = this.files[0];
      reader.readAsText(file);
    };
  </script>

</div>

</body></html>
