<!DOCTYPE html>

<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>Parallel Coordinates Visualization</title>

  <!-- Core -->
  <link rel="stylesheet" type="text/css" href="styles/style_custom.css">
  <link rel="stylesheet" type="text/css" href="styles/d3.parcoords_ucb.css">

  <script type="text/javascript" src="src/d3.min.js"></script>
  <script type="text/javascript" src="src/d3.csv.js"></script>
  <script type="text/javascript" src="src/d3.parcoords_ucb.js"></script>
  <script type="text/javascript" src="src/d3.svg.multibrush.js"></script>
  <script type="text/javascript" src="src/underscore.js"></script>
  <script type="text/javascript" src="src/divgrid.js"></script>
  <script type="text/javascript" src="src/colorbrewer_schemes.js"></script>

  <!-- SlickGrid -->
  <link rel="stylesheet" href="src/slickgrid/slick.grid_default.css" type="text/css" media="screen" charset="utf-8">
  <link rel="stylesheet" href="src/slickgrid/jquery-ui-1.8.16.custom.css" type="text/css" />
  <link rel="stylesheet" href="src/slickgrid/plugins/slick.columnpicker.css" type="text/css"/>

  <script type="text/javascript" src="src/slickgrid/jquery-1.7.min.js"></script>
  <script type="text/javascript" src="src/slickgrid/jquery.event.drag-2.0.min.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.core.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.grid.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.dataview.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.formatters.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.editors.js"></script>

  <script src="src/slickgrid/plugins/slick.checkboxselectcolumn.js"></script>
  <script src="src/slickgrid/plugins/slick.autotooltips.js"></script>
  <script src="src/slickgrid/plugins/slick.cellrangedecorator.js"></script>
  <script src="src/slickgrid/plugins/slick.cellrangeselector.js"></script>
  <script src="src/slickgrid/plugins/slick.cellcopymanager.js"></script>
  <script src="src/slickgrid/plugins/slick.cellselectionmodel.js"></script>
  <script src="src/slickgrid/plugins/slick.rowselectionmodel.js"></script>
  <script src="src/slickgrid/plugins/slick.columnpicker.js"></script>

</head>

<body>
<!-- Page Header -->
<div id="nav">
  <h1>Parallel Coordinates</h1>
    Links to info and tutorials:
    <a href="https://waterprogramming.wordpress.com/">Example</a>
    <a href="https://waterprogramming.wordpress.com/">Example</a>
</div>

<div id="main">
  <!-- Interactive Buttons -->
  <div class="widgets">
    <input type="file" id="uploader">
    <button id="keep_selected">Keep</button>
    <button id="remove_selected">Remove</button>
    <button id="export_data">Export</button>


    <button id="brush_reset">Reset Brushes</button>
    <button id="clear_selected">Clear Selections</button>

    <button id="axes_limits">Set Axes Limits</button>
    <button id="cluster">Clustering</button>
  </div>

  <h3>Objective Space</h3>
  <button id="svg01">Save Image</button>
  <div id="plot01" class="parcoords" style="height:200px; width=100%;"></div>

  <h3>Decision Space</h3>
  <button id="svg02">Save Image</button>
  <div id="plot02" class="parcoords" style="height:200px; width=100%;"></div>

  <div id="grid"></div>

  <!-- Begin Script -->
  <script type="text/javascript">

  // define parallel coordinates variables
  var pc1 = d3.parcoords()("#plot01")
    .alpha(0.4)
    .mode("queue")
    .height(200)
    .margin({
      top: 16,
      left: 16,
      right: 16,
      bottom: 16
    });

  var pc2 = d3.parcoords()("#plot02")
    .alpha(0.4)
    .mode("queue")
    .height(200)
    .margin({
      top: 16,
      left: 16,
      right: 16,
      bottom: 16
    });


    function parallelCoordinates(data) {
      // slickgrid needs each data element to have an id
      data.forEach(function(d,i) { d.id = d.id || i; });

      /*
      // vertical full screen
      var parallel_height = $(window).height() - 64 - 12 - 120 - 320;
      if (parallel_height < 120) parallel_height = 120;  // min height
      if (parallel_height > 340) parallel_height = 340;  // max height
      $('#pc1').css({
          height: parallel_height + 'px',
          width: $(window).width() + 'px'
      });
      $('#pc2').css({
          height: parallel_height + 'px',
          width: $(window).width() + 'px'
      });
      */

      // TODO: allow user to set number of obj vars
      var variables = d3.keys(data[0]).slice(0,-1); //remove id col
      var id_col = d3.keys(data[0]).pop()
      var objective_vars = _.union(variables.slice(0,3), [id_col]);
      var decision_vars = _.union(variables.slice(3), [id_col]);

      // keep track of brushed data
      var brushed_pc1 = [];
      var brushed_pc2 = [];

      // not necessary eventually
      var isBrushed_pc1 = false;
      var isBrushed_pc2 = false;

      // objective space
      pc1
        .data(data)
        .hideAxis(decision_vars)
        .render()
        .shadows()
        .reorderable()
        .brushMode("1D-axes")
        .on("brushend", function(brushed) {

          if (isBrushed_pc2) {
            // pc2 has brushes, keep only the intersection of arrays
            brushed_pc2 = _.intersection(brushed_pc2, brushed);
          } else {
            brushed_pc2 = brushed;
          }

          brushed_pc1 = brushed_pc2;
          isBrushed_pc1 = true;

          pc2.brushed(brushed_pc2);
          pc2.render();

          pc1.brushed(brushed_pc1);
          pc1.render();

          gridUpdate(brushed_pc2);
        });

      // decision space
      pc2
        .data(data)
        .hideAxis(objective_vars)
        .render()
        .shadows()
        .reorderable()
        .brushMode("1D-axes")
        .on("brushend", function(brushed) {

          if (isBrushed_pc1) {
            // pc1 has brushes, keep only the intersection of arrays
            brushed_pc1 = _.intersection(brushed_pc1, brushed);
          } else {
            brushed_pc1 = brushed;
          }

          brushed_pc2 = brushed_pc1;
          isBrushed_pc2 = true;

          pc2.brushed(brushed_pc1);
          pc2.render();

          pc1.brushed(brushed_pc2);
          pc1.render();

          gridUpdate(brushed_pc1);
        });


      // slick grid setup
      var column_keys = d3.keys(data[0]).slice(0,-1); //remove id col
      var columns = column_keys.map(function(key,i) {
        return {
          id: key,
          name: key,
          field: key,
          sortable: true
        }
      });

      var options = {
        enableCellNavigation: true,
        enableColumnReorder: false,
        multiColumnSort: false,
        editable: true,
        asyncEditorLoading: false,
        autoEdit: false
      };

      var checkboxSelector = new Slick.CheckboxSelectColumn({
        cssClass: "slick-cell-checkboxsel"
      });
      columns.unshift(checkboxSelector.getColumnDefinition());

      var dataView = new Slick.Data.DataView();
      var grid = new Slick.Grid("#grid", dataView, columns, options);
      grid.setSelectionModel(new Slick.RowSelectionModel({selectActiveRow: false}));
      grid.registerPlugin(checkboxSelector);

      // wire up model events to drive the grid
      dataView.onRowCountChanged.subscribe(function (e, args) {
        grid.updateRowCount();
        grid.render();
      });

      dataView.onRowsChanged.subscribe(function (e, args) {
        grid.invalidateRows(args.rows);
        grid.render();
      });

      // keep checkboxes matched with row on filter/brush
      dataView.syncGridSelection(grid, preserveHidden=false); //vs true

      // column sorting
      var sortcol = column_keys[0];
      var sortdir = 1;

      function comparer(a, b) {
        var x = a[sortcol], y = b[sortcol];
        return (x == y ? 0 : (x > y ? 1 : -1));
      }

      // click header to sort grid column
      grid.onSort.subscribe(function (e, args) {
        sortdir = args.sortAsc ? 1 : -1;
        sortcol = args.sortCol.field;

        if ($.browser.msie && $.browser.version <= 8) {
          dataView.fastSort(sortcol, args.sortAsc);
        } else {
          dataView.sort(comparer, args.sortAsc);
        }
      });

      // highlight row in chart
      grid.onMouseEnter.subscribe(function(e, args) {
        var i = grid.getCellFromEvent(e).row;
        var d1 = pc1.brushed() || data;
        var d2 = pc2.brushed() || data;
        pc1.highlight([d1[i]]);
        pc2.highlight([d2[i]]);
      });
      grid.onMouseLeave.subscribe(function(e, args) {
        pc1.unhighlight();
        pc2.unhighlight();
      });

      grid.onSelectedRowsChanged.subscribe(function (e, args) {
        // reset and update selected rows
        var selected_row_ids = grid.getSelectedRows();
        var d = _union(pc1.brushed(), pc2.brushed()) || data;

        pc1.deselect();
        pc2.deselect();
        selected_row_ids.forEach(function(i) {
           pc1.select([d[i]]);
           pc2.select([d[i]]);
         });
      });

      // fill grid with data
      gridUpdate(data);


      function gridUpdate(data) {
        dataView.beginUpdate();
        dataView.setItems(data);
        // if selected data exists, keep in grid
        // only need to look at once plot since selections are universal
        if (pc1.selected().length) {
          pc1.selected().forEach(function(i) { dataView.insertItem(0,i); });
        }
        dataView.endUpdate();
      };

      // clear selections
      d3.select('#clear_selected').on('click', function() {
        // deselect all elements in grid (fires event)
        grid.setSelectedRows([]);
      });

      // reset brushes
      d3.select('#brush_reset').on('click', function() {
        // reset global vars
        console.log("went here");
        brushed_pc1 = [];
        brushed_pc2 = [];
        isBrushed_pc1 = false;
        isBrushed_pc2 = false;

        pc1.brushReset();
        pc2.brushReset();

        gridUpdate(data);
      });

    };


    // CSV Uploader
    var uploader = document.getElementById("uploader");
    var reader = new FileReader();

    reader.onload = function(e) {
      var contents = e.target.result;
      var data = d3.csv.parse(contents);
      // NOTE: remove after testing
      data.forEach(function(car) {
        delete car.name;
        delete car.year;
      });
      parallelCoordinates(data);

      // remove uploader button, since re-initializing doesn't work
      uploader.parentNode.removeChild(uploader);
    };

    uploader.addEventListener("change", handleFiles, false);

    function handleFiles() {
      var file = this.files[0];
      reader.readAsText(file);
    };

  </script>

</div>

</body></html>
