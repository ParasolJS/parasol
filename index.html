<!DOCTYPE html>

<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>ParaSol.js Showcase</title>

  <!-- Core -->
  <link rel="stylesheet" type="text/css" href="styles/style_custom.css">
  <link rel="stylesheet" type="text/css" href="styles/d3.parcoords_ucb.css">

  <script type="text/javascript" src="src/d3.min.js"></script>
  <script type="text/javascript" src="src/d3-dsv.min.js"></script>
  <script type="text/javascript" src="src/d3.parcoords_ucb.js"></script>
  <script type="text/javascript" src="src/d3.svg.multibrush.js"></script>
  <script type="text/javascript" src="src/jquery-1.7.min.js"></script>
  <script type="text/javascript" src="src/underscore.js"></script>
  <script type="text/javascript" src="src/divgrid.js"></script>
  <script type="text/javascript" src="src/ml.min.js"></script>
  <script type="text/javascript" src="src/colorbrewer.js"></script>

  <!-- SlickGrid -->
  <link rel="stylesheet" href="src/slickgrid/slick.grid_default.css" type="text/css" media="screen" charset="utf-8">
  <link rel="stylesheet" href="src/slickgrid/jquery-ui-1.8.16.custom.css" type="text/css" />
  <link rel="stylesheet" href="src/slickgrid/plugins/slick.columnpicker.css" type="text/css"/>

  <script type="text/javascript" src="src/slickgrid/jquery.event.drag-2.0.min.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.core.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.grid.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.dataview.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.formatters.js"></script>
  <script type="text/javascript" src="src/slickgrid/slick.editors.js"></script>

  <script src="src/slickgrid/plugins/slick.checkboxselectcolumn.js"></script>
  <script src="src/slickgrid/plugins/slick.autotooltips.js"></script>
  <script src="src/slickgrid/plugins/slick.cellrangedecorator.js"></script>
  <script src="src/slickgrid/plugins/slick.cellrangeselector.js"></script>
  <script src="src/slickgrid/plugins/slick.cellcopymanager.js"></script>
  <script src="src/slickgrid/plugins/slick.cellselectionmodel.js"></script>
  <script src="src/slickgrid/plugins/slick.rowselectionmodel.js"></script>
  <script src="src/slickgrid/plugins/slick.columnpicker.js"></script>

</head>

<body>
<!-- Page Header -->
<div id="nav">
  <h1>ParaSol.js</h1>
    Links to info and tutorials:
    <a href="https://waterprogramming.wordpress.com/">Example</a>
    <a href="https://waterprogramming.wordpress.com/">Example</a>
</div>

<div id="main">
  <!-- Interactive Buttons -->
  <div class="widgets">
    <input type="file" id="uploader">
    <button id="keep_selected">Keep</button>
    <button id="remove_selected">Remove</button>

    <!-- <button href='#'
      onclick='downloadCSV(data);'
    >Export</button> -->

    <button href='#'id='export_selected'>Export</button>


    <button id="brush_reset">Reset Brushes</button>
    <button id="clear_selected">Clear Selections</button>

    <button id="axes_limits">Set Axes Limits</button>
    <input type="select" id="cluster">Clustering</button>
  </div>
  <div id="plots"></div>
  <div id="grid"></div>

  <!-- Begin Script -->
  <script type="text/javascript">

    var plot = `<h3>Objective Space</h3>
    <button id="svg01">Save Image</button>
    <div id="plot01" class="parcoords" style="height:200px; width=100%;"></div>

    <h3>Decision Space</h3>
    <button id="svg02">Save Image</button>
    <div id="plot02" class="parcoords" style="height:200px; width=100%;"></div>
    `
    $("div#plots").html(plot);

    // clustering library
    var kmeans = ML.Clust.kmeans;

    function visualize(data, n_objs, k = 3) {

      // check that n_objs < length data - 1
      if (n_objs >= d3.keys(data[0]).length - 1) {
        throw new Error("Number of objectives exceeds length of data.");
      }

      // max clusters = 6
      k = (k <= 6) ?  k : 3;

      // coerce data to array of arrays for clustering
      var clust_form = [];
      data.forEach(function(d,i) { clust_form[i] = _.values(d) });

      // preform default clustering
      var km = kmeans(clust_form, k);
      data.forEach(function(d,i) { d.cluster = km.clusters[i]; });

      // slickgrid needs each data element to have an id
      data.forEach(function(d,i) { d.id = d.id || i; });

      // choose default catagorical color scheme
      var color_scheme = d3.scale.ordinal()
        .range(colorbrewer.Dark2[k])
      // can we use d3 instead, or is the new version not compatible
      // var color_scheme = d3.scaleOrdinal(d3.schemeCategory10);

      var palette = function(d) {
        return color_scheme(d['cluster']);
      };

      var variables = d3.keys(data[0]).slice(0,-1); //remove id col
      var id_col = "id"
      var k_col = "cluster";

      // NOTE: hide clusters by default but allow user to display via button
      var objective_vars = _.union(variables.slice(0, n_objs), [k_col], [id_col]);
      // var decision_vars = _.union(variables.slice(n_objs), [id_col])
      var decision_vars = _.difference(variables.slice(n_objs), [k_col]);
      decision_vars = _.union(decision_vars, [id_col])

      function hide_var(axis) {
        console.log("went here");
        // TODO: enforce name cast as array
        if ( ! _.difference(axis, objective_vars).length) {
          // in objectives so we want to add it to decisions which are hidden
          // keep list of post-hidden
          // decision_vars = _.union(decision_vars, axis);
          //pc1.dimensions(pc1.applyDimensionDefaults());
          pc1.dimensions(d3.parcoords_ucb.without(pc1.dimensions, axis.value));
          console.log("objective");
        } else if ( ! _.difference(axis, decision_vars).length) {
          // in decisions so we want to add it to objectives which are hidden
          //objective_vars = _.union(objective_vars, [axis]);
          //pc2.dimensions(pc1.applyDimensionDefaults());
          pc2.dimensions(d3.parcoords_ucb.without(pc1.dimensions, axis.value));
          console.log("decision");
        } else {
          // not in dataset
          throw new Error("Variable not found.");
        }
      };

      // function show_var(axis, data) {
      //
      // }

      // keep track of brushed data
      var brushed_pc1 = [];
      var brushed_pc2 = [];
      var isBrushed_pc1 = false;
      var isBrushed_pc2 = false;

      // define parallel coordinates variables

      // objective space
      var pc1 = d3.parcoords()("#plot01")
      .data(data)
      .hideAxis(decision_vars)
      .color(palette)
      .height(200)
      .alpha(0.4)
      .mode("queue")
      .render()
      .shadows()
      .reorderable()
        .brushMode("1D-axes")
        .on("brushend", function(brushed) {

          if (isBrushed_pc2) {
            // pc2 has brushes, keep only the intersection of arrays
            brushed_pc2 = _.intersection(brushed_pc2, brushed);
          } else {
            brushed_pc2 = brushed;
          }

          brushed_pc1 = brushed_pc2;
          isBrushed_pc1 = true;

          pc2.brushed(brushed_pc2);
          pc2.render();

          pc1.brushed(brushed_pc1);
          pc1.render();

          gridUpdate(brushed_pc2);
        });

      // decision space
      var pc2 = d3.parcoords()("#plot02")
        .data(data)
        .hideAxis(objective_vars)
        .color(palette)
        .height(200)
        .alpha(0.4)
        .mode("queue")
        .render()
        .shadows()
        .reorderable()
        .brushMode("1D-axes")
        .on("brushend", function(brushed) {

          if (isBrushed_pc1) {
            // pc1 has brushes, keep only the intersection of arrays
            brushed_pc1 = _.intersection(brushed_pc1, brushed);
          } else {
            brushed_pc1 = brushed;
          }

          brushed_pc2 = brushed_pc1;
          isBrushed_pc2 = true;

          pc2.brushed(brushed_pc1);
          pc2.render();

          pc1.brushed(brushed_pc2);
          pc1.render();

          gridUpdate(brushed_pc1);
        });


      // slick grid setup
      var column_keys = d3.keys(data[0]).slice(0,-1); //remove id col
      var columns = column_keys.map(function(key,i) {
        return {
          id: key,
          name: key,
          field: key,
          sortable: true
        }
      });

      var options = {
        enableCellNavigation: true,
        enableColumnReorder: false,
        multiColumnSort: false,
        editable: true,
        asyncEditorLoading: false,
        autoEdit: false
      };

      var checkboxSelector = new Slick.CheckboxSelectColumn({
        cssClass: "slick-cell-checkboxsel"
      });
      columns.unshift(checkboxSelector.getColumnDefinition());

      var dataView = new Slick.Data.DataView();
      var grid = new Slick.Grid("#grid", dataView, columns, options);
      grid.setSelectionModel(new Slick.RowSelectionModel({selectActiveRow: false}));
      grid.registerPlugin(checkboxSelector);

      // wire up model events to drive the grid
      dataView.onRowCountChanged.subscribe(function (e, args) {
        grid.updateRowCount();
        grid.render();
      });

      dataView.onRowsChanged.subscribe(function (e, args) {
        grid.invalidateRows(args.rows);
        grid.render();
      });

      // keep checkboxes matched with row on filter/brush
      dataView.syncGridSelection(grid, preserveHidden=false); //vs true

      // column sorting
      var sortcol = column_keys[0];
      var sortdir = 1;

      function comparer(a, b) {
        var x = a[sortcol], y = b[sortcol];
        return (x == y ? 0 : (x > y ? 1 : -1));
      }

      // click header to sort grid column
      grid.onSort.subscribe(function (e, args) {
        sortdir = args.sortAsc ? 1 : -1;
        sortcol = args.sortCol.field;

        if ($.browser.msie && $.browser.version <= 8) {
          dataView.fastSort(sortcol, args.sortAsc);
        } else {
          dataView.sort(comparer, args.sortAsc);
        }
      });

      // highlight row in chart
      grid.onMouseEnter.subscribe(function(e, args) {
        var i = grid.getCellFromEvent(e).row;
        var d1 = pc1.brushed() || data;
        var d2 = pc2.brushed() || data;
        pc1.highlight([d1[i]]);
        pc2.highlight([d2[i]]);
      });
      grid.onMouseLeave.subscribe(function(e, args) {
        pc1.unhighlight();
        pc2.unhighlight();
      });

      // select row in chart
      grid.onSelectedRowsChanged.subscribe(function (e, args) {
        // reset and update selected rows
        var selected_row_ids = grid.getSelectedRows();
        var brush_union = _.union(pc1.brushed(), pc2.brushed());
        var d;
        if (brush_union.length) {
          d = brush_union;
        } else {
          d = data;
        }
        pc1.deselect();
        pc2.deselect();
        selected_row_ids.forEach(function(i) {
           pc1.select([d[i]]);
           pc2.select([d[i]]);
         });
      });

      // fill grid with data
      gridUpdate(data);


      function gridUpdate(data) {
        dataView.beginUpdate();
        dataView.setItems(data);
        // if selected data exists, keep in grid
        // only need to look at once plot since selections are linked
        if (pc1.selected().length) {
          pc1.selected().forEach(function(i) { dataView.insertItem(0,i); });
        }
        dataView.endUpdate();
      };

      // clear selections
      d3.select('#clear_selected').on('click', function() {
        // deselect all elements in grid (fires event)
        grid.setSelectedRows([]);
      });

      // reset brushes
      d3.select('#brush_reset').on('click', function() {
        // reset global vars
        brushed_pc1 = [];
        brushed_pc2 = [];
        isBrushed_pc1 = false;
        isBrushed_pc2 = false;

        pc1.brushReset();
        pc2.brushReset();

        gridUpdate(data);
      });

      // TEST: hide / show variable
      // hide_var(["cluster"]);

      // keep selected
      d3.select('#keep_selected').on('click', function() {
        // delete all data not slected and do complete refresh
        // only need to look at one plot since selections are linked
        var keep = pc1.selected() || pc1.brushed();
        console.log(keep);
        if (keep.length >= k ) {
          // clear canvas layers
          $("div#plot01").html("");
          $("div#plot02").html("");
          $("div#plot").html(plot);
          // for complete reset, clusters will be recomputed
          visualize(data, n_objs = n_objs, k = k);
        } else {
          throw new Error("Not enough data selected to perform clustering.");
        }
      });

      // remove selected
      d3.select('#remove_selected').on('click', function() {
        console.log("before:", data.length);
        // delete all selected data and do complete refresh
        if (pc1.selected().length) {
          data = _.difference(data, pc1.selected());
          if (data.length >= k) {
            // clear canvas layers
            $("div#plot01").html("");
            $("div#plot02").html("");
            $("div#plot").html(plot);
            // for complete reset, clusters will be recomputed
            visualize(data, n_objs = n_objs, k = k);
          }
        } else {
          throw new Error("Not enough data remaining to perform clustering.");
        }
        console.log("after:", data.length);
      });

      // export selected
      d3.select('#export_selected').on('click', function() {
        // export selected data to new csv and download
        // TODO: decide on what to export
        var data_exp = pc1.selected();

        if (data_exp == null || !data_exp.length) {
            throw new Error("No data selected.");
            return;
        }

        // format data as csv
        var columns = d3.keys(data_exp[0]);
        var csv = d3.csvFormat(data_exp, columns);

        // create url for download
        var file = new Blob([csv], {type: 'text/csv'});
        var url = URL.createObjectURL(file);
        console.log(url);

        // create hidden DOM element
        var filename = 'pareto_solutions.csv'
        var link = document.createElement('a');
        console.log(link);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        document.body.appendChild(link); // Required for FF
        link.click();

      });

    };


    // CSV Uploader
    var uploader = document.getElementById("uploader");
    var reader = new FileReader();

    reader.onload = function(e) {
      var contents = e.target.result;
      var data = d3.csv.parse(contents);
      // NOTE: remove after testing
      data.forEach(function(car) {
        delete car.name;
        delete car.year;
      });

      // // visualize data with default to 3 clusters
      visualize(data, n_objs = 3, k = 3);

      // remove uploader button, since re-initializing doesn't work
      uploader.parentNode.removeChild(uploader);
    };

    uploader.addEventListener("change", handleFiles, false);

    function handleFiles() {
      var file = this.files[0];
      reader.readAsText(file);
    };
  </script>

</div>

</body></html>
